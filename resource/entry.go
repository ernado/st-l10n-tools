package resource

import (
	"fmt"
	"io"
	"log"
	"sort"
	"strconv"
	"strings"
)

type Entry struct {
	File              string `json:"file"` // without extension
	TranslatorComment string `json:"translator_comment,omitempty"`
	Reference         string `json:"reference,omitempty"`
	ID                string `json:"id"`
	Str               string `json:"str"`
	Context           string `json:"context,omitempty"`
	Original          string `json:"original"`
}

type Entries []Entry

func (e Entries) DifferentFromOriginal() Entries {
	var b Entries
	for _, entry := range e {
		if entry.Str == "" {
			continue
		}
		if entry.Str == entry.Original {
			continue
		}
		if entry.Original == "" {
			continue
		}
		b = append(b, entry)
	}
	return b
}

func (e Entries) TranslatedCount() int {
	var count int
	for _, entry := range e {
		if entry.Str == "" {
			continue
		}
		count++
	}
	return count
}

func (e Entries) Files() []string {
	m := make(map[string]bool)
	for _, entry := range e {
		m[entry.File] = true
	}
	files := make([]string, 0, len(m))
	for k := range m {
		files = append(files, k)
	}
	sort.Strings(files)
	return files
}

type entryKey struct {
	ID      string
	Context string
}

func (e Entries) WriteTemplateFile(file string, w io.Writer) error {
	_, err := fmt.Fprintln(w, "# Stationeers template translation file generated by martian.")
	if err != nil {
		return err
	}
	wrote := make(map[entryKey]struct{})
	for _, entry := range e {
		k := entryKey{
			ID:      entry.ID,
			Context: entry.Context,
		}
		if entry.File != file {
			continue
		}
		if _, ok := wrote[k]; ok {
			// Early fix for duplicates.
			continue
		}
		wrote[k] = struct{}{}
		entry.Str = ""
		if err = entry.WriteTo(w); err != nil {
			return err
		}
	}
	return nil
}

func (e Entries) WriteFile(file string, w io.Writer) error {
	_, err := fmt.Fprintf(w, "# Stationeers translation file generated by martian.\n")
	if err != nil {
		return err
	}
	// 2018-09-24 10:59+0000
	fmt.Fprintf(w, `# 
#, fuzzy
msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"
"X-Generator: Martian\n"`,
	)
	fmt.Fprint(w, "\n")
	wrote := make(map[entryKey]string)
	for _, entry := range e {
		k := entryKey{
			ID:      entry.ID,
			Context: entry.Context,
		}
		if entry.File != file {
			continue
		}
		if ref, ok := wrote[k]; ok {
			// Early fix for duplicates.
			log.Println("warning: duplicate", entry.Reference, "and", ref)
			continue
		}
		wrote[k] = entry.Reference
		if err = entry.WriteTo(w); err != nil {
			return err
		}
	}
	return nil
}

func (e Entries) Len() int {
	return len(e)
}

func (e Entries) Less(i, j int) bool {
	a, b := e[i], e[j]
	for _, s := range []struct {
		aStr, bStr string
	}{
		{a.File, b.File},
		{a.Context, b.Context},
		{a.ID, b.ID},
		{a.Reference, b.Reference},
		{a.TranslatorComment, b.TranslatorComment},
	} {
		if strings.Compare(s.aStr, s.bStr) < 0 {
			return true
		} else {
			return false
		}
	}
	return false
}

func (e Entries) Swap(i, j int) {
	e[i], e[j] = e[j], e[i]
}

func Escape(raw string) string {
	return strings.ReplaceAll(strconv.Quote(raw), "\\u00a0", "Â ")
}

func (e Entry) WriteTo(w io.Writer) error {
	fmt.Fprint(w, "\n")
	if len(e.TranslatorComment) > 0 {
		fmt.Fprintf(w, "# %s\n", e.TranslatorComment)
	}
	if len(e.Reference) > 0 {
		fmt.Fprintf(w, "#: %s\n", e.Reference)
	}
	if len(e.Context) > 0 {
		fmt.Fprintf(w, "msgctxt %q\n", e.Context)
	}
	fmt.Fprintf(w, "msgid %s\n", Escape(e.ID))
	fmt.Fprintf(w, "msgstr %s\n", Escape(e.Str))
	return nil
}
